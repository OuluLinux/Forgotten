using "Com/Com.fog";

namespace Main {
using/interface Native;
using/interface Container;
using/interface Shared;
using/interface Stream;
using/interface Util;
using/interface Math;
using/interface Chrono;
using/interface Indirect;
using/interface Concurrency;
using/interface Network;
using/interface TextProc;


class App {
	//typedef Vector<String> StrVec;
	//StrVec strvec;
	//VectorMap<int, int> map;
	//Vector<int> arr;
	VectorMap<int, int> arr;
	//DynArray<int> arr;
	
	struct TestCmp {
		bool operator()(const char& c) {
			return c == 'c';
		}
	};
	
	struct VirtualBase {
		VirtualBase() {}
		virtual ~VirtualBase() {}
		
		int a = 3;
	};
	struct DerivedBase : public VirtualBase {
		DerivedBase() {}
		
		int a = 8;
	};
	
	$Tuple2(SomeTuple2, int, double);
	$RefTuple2(SomeRefTuple2, int, double);
	
	inline public void Run() {
		uint64 v = UINT_MAX;
		ASSERT(sizeof(v) == 8);
		
		VoidPtr p;
		ASSERT(p == NULL);
		
		ASSERT(SignificantBits(0x8000) == 16);
		ASSERT(SignificantBits64(0x8000) == 16);
		
		CombineHash ch;
		ch.Put(777999777).Put(123).Put64(0xF0F0F0F0F0F0F0F0);
		dword hash = ch;
		ASSERT(hash == 1894504625);
		int a = 0;
		int b = 1;
		ASSERT(Min(a, b) < Max(a, b));
		
		int r = Random::Int();
		float f = Random::Float();
		float d = Random::Double();
		int j = d;
		
		
		const char* test_str = "abcdef";
		int test_strlen = StringLength(test_str);
		ASSERT(FindIf(test_str, test_str + test_strlen, TestCmp()) == test_str + 2);
		
		
		ASSERT(String("test") == "test");
		ASSERT(DblStr(1.2) == "1.2");
		ASSERT((String)"abc" + String("def") == "abcdef");
		ASSERT(String("abc") + "def" == "abcdef");
		ASSERT(ToString(ToWString<String>("abc")) == "abc");
		ASSERT(ToInt<String>("123") == 123);
		ASSERT(ToString(123) == "123");
		ASSERT(HexStr((void*)0x123f) == "0x123F");
		
		
		SomeTuple2 ttt = {1, 1.2};
		ASSERT(ToString(ttt) == "1, 1.2");
		
		SomeRefTuple2 tttref(ttt.a, ttt.b);
		ASSERT(ToString(tttref) == "1, 1.2");
		
		One<String> onestr;
		onestr.Create();
		*onestr = "hello";
		ASSERT(*onestr == "hello");
		
		One<VirtualBase> onebase;
		onebase.CreateDerived<DerivedBase>();
		ASSERT(onebase.GetDerived<DerivedBase>()->a == 8);
		
		FutureOne<String> fone;
		fone = new String;
		fone.Wait();
		
		Vector<String> strvec;
		Array<String> strarr;
		for(int i = 0; i < 3; i++) {
			strvec << IntStr(i);
			strarr << IntStr(i);
		}
		for(int i = 0; i < 3; i++) {
			ASSERT(strvec[i] == strarr[i]);
		}
		
		Index<String> stridx;
		stridx.Add("abc");
		ASSERT(stridx.GetCount() == 1);
		ASSERT(stridx.Find("abc") == 0);
		stridx.Add("def");
		ASSERT(stridx.Find("abc") == 0);
		ASSERT(stridx.Find("def") == 1);
		
		
		VectorMap<String, int> vmap;
		ArrayMap<String, int> amap;
		
		vmap.Add("abc", 123);
		vmap.Add("def", 456);
		ASSERT(vmap.GetKeys().Find("abc") == 0);
		ASSERT(vmap.GetValues()[0] == 123);
		ASSERT(vmap.Find("abc") == 0);
		ASSERT(vmap.Find("dfasgsg") == -1);
		ASSERT(vmap.GetValues().Join() == "123456");
		Vector<int> vmap_keys;
		vmap_keys.Split(vmap.GetValues().Join(" "), " ");
		ASSERT(vmap_keys.GetCount() == 2 && vmap_keys[0] == 123 && vmap_keys[1] == 456);
		
		
		amap.Add("abc", 123);
		amap.Add("def", 456);
		ASSERT(amap.GetKeys().Find("abc") == 0);
		ASSERT(amap.GetValues()[0] == 123);
		ASSERT(amap.Find("abc") == 0);
		ASSERT(amap.Find("dfasgsg") == -1);
		FwdPairPtrIterator<String,int> it = amap.Begin();
		for(int i = 0; i < 2; i++) {
			if (i == 0) {
				ASSERT(it.GetKey() == "abc");
				ASSERT(it.GetValue() == 123);
			}
			else if (i == 1) {
				ASSERT(it.GetKey() == "def");
				ASSERT(it.GetValue() == 456);
			}
			++it;
		}
		
		
		{
			Shared::Attachable a;
			Shared::Slot s;
			a.Attach(s);
			s.Clear();
		}
		
		
		TestShared();
		
		{
			StringStream ss;
			ss << "abc";
		}
		
		{
			WStringStream wss;
			wss.Cat('t');
			wss.Cat('e');
			wss.Cat('s');
			wss.Cat('t');
			ASSERT(ToString(wss.GetResult()) == "test");
		}
		
		String s;
		{
			FileIn fin;
			ASSERT(fin.Open("/home/sblo/Fuck.cxx"));
			s = fin.Get(fin.GetSize());
			int sz = s.GetCount();
		}
		
		Log() << "Lol does this work?\n";
		
		FileOut fout;
		fout % r % f % d;
		
		const Vector<String>& cmd = Env::Local().CommandLine();
		for(int i = 0; i < cmd.GetCount(); i++) {
			String arg = cmd[i];
		}
		
		Index<String> files;
		GetDirectoryFiles("/", files);
		ASSERT(files.Find("home") >= 0);
		for(int i = 0; i < files.GetCount(); i++) {
			String s = files[i];
			const char* c = s.Begin();
			int len = StringLength(c);
		}
		
		{
			double d = FastSin(M_PI);
			d = FastCos(M_PI);
		}
		
		{
			RandomGaussian& gaus = GetRandomGaussian(13);
			double d = gaus;
			d = gaus;
			d = gaus;
			d = gaus;
		}
		
		{
			Time t1(2020,10,5,3,28,0);
			int64 i64 = t1.Get();
			Time t2;
			t2.Set(i64);
			ASSERT(t1 == t2);
			Time t3 = GetSysTime();
		}
		
		
		{
			Thread t;
			Mutex m;
		}
		
		{
			TcpSocket s;
			ASSERT(s.Listen(8005, 5));
		}
		
		{
			TextProc::Tokenizer t;
			
		}
		
		{
			JSON j;
		}
		
		/* TODO
			- log init GetSysTime
		*/
		
		//for (char& c: strvec) c += 1;
		//for (char& c: strarr) c += 1;
		
		
		
		/*ConstChar* c = s;
		Console::Put("Starting Com-testing\n");*/
		
		/*Console::Put(program.GetVertexSource());
		
		Console::Put("\n\n");
		Console::Put("Fragment source:\n");
		Console::Put(program.GetFragmentSource());*/
		
	}
	
	#undef LOG
	#define LOG(x)
	
	struct Dumber {
		Dumber() {LOG("Dumber ctor +++");}
		virtual ~Dumber() {LOG("Dumber dtor ---");}
	};
	struct Dumb : public Dumber {
		Dumb() {LOG("Dumb ctor ++++++");}
		~Dumb() {LOG("Dumb dtor ------");}
	};
	
	void TestShared() {
		
		
		#define DUMPDUMB(x, y)
		/*#define DUMPDUMB(x, y) {\
			LOG(#x ": " #y ": refs ");\
			if (y.GetBase()) {LOG((int)y.GetBase()->refs);} else {LOG(-1);}\
			LOG(", " << IntStr64((uint64)y.GetBase()));\
		}*/
		
		SharedPtr<Dumb> s0a;
		DUMPDUMB(0, s0a);
		{
			SharedPtr<Dumber> s1a;
			SharedPtr<Dumb> s1b;
			DUMPDUMB(1, s1a);
			DUMPDUMB(2, s1b);
			
			s1b = SharedPtr<Dumb>().WrapObject(new Dumb());
			DUMPDUMB(3, s1b);
			
			s1a = s1b.template As<Dumber>();
			DUMPDUMB(4, s1a);
			
			{
				SharedPtr<Dumber> s2;
				DUMPDUMB(5, s2);
				s2 = s1a;
				DUMPDUMB(6, s2);
				s0a = s2.template As<Dumb>();
				DUMPDUMB(7, s0a);
			}
			DUMPDUMB(8, s0a);
		}
		DUMPDUMB(9, s0a);
		
	}
};


}


$MainClassApp();





/*namespace Test {
using/interface Native;
using/interface Container;
using/interface Com;
using/interface Text;

struct Tester {
	
	!inline Tester() {
		Container::Vector<String> strvec;
		strvec.Add("abc");
	}
};


}*/


/*
auto declaration defer(class clientClass)
{
${${clientClass}::deferred($Scope)};
}
*/


/*auto declaration BuildInterface() {
	auto for (iterator k = $variables(); k; ++k) {
		!inline $k->derive_type() get_${k->name()} () {return $k->name();}
		!inline void set_${k->name()} (const $k->derive_type()& v) {$k->name() = v;;}
	}
}

struct Person {
	export/interface WebGL;
	export/implementation WebGL;
	
	int age;
	double length;
	
	$BuildInterface();
	
};*/

/*struct GeneratedInterface {
	
};

auto GeneratedInterface::~GeneratedInterface() {
	for (iterator k = $variables(); k; ++k) {
		!inline static void get_${k->name()} () ;
	}
}

struct Person : auto virtual GeneratedInterface {};*/



