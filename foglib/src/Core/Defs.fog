auto string PLATFORM = "UNKNOWN";
auto number CPU_32 = 0;
auto number CPU_64 = 0;

auto statement DebugMetaLog(string s) {
	auto if (true)
		auto $std::diagnostic($s);
};

auto bool IsDefined(identifier id) {
	$std::defined(id);
}

auto if ($IsDefined("CPU64")) {
	$DebugMetaLog("Using 64bit cpu");
	
	CPU_64 = 1;
}
else if ($IsDefined("CPU32")) {
	$DebugMetaLog("Using 32bit cpu");
	
	CPU_64 = 1;
}
else $std::error("Define cpu bits: CPU32 or CPU64");

auto if ($IsDefined("POSIX")) {
	$DebugMetaLog("Using Posix OS");
	
	auto string DIR_SEPS = "/";
	auto char DIR_SEP = '/';
	auto string ENDL = "\n";
	auto PLATFORM = "POSIX";
}
else if ($IsDefined("WIN32")) {
	$DebugMetaLog("Using Windows OS");
	
	auto string DIR_SEPS = "\\";
	auto char DIR_SEP = '\\';
	auto string ENDL = "\r\n";
	auto PLATFORM = "POSIX";
}
else
	$std::error("No OS defined. Define POSIX or WIN32");


auto character to_character(token t) { $t }
auto identifier to_identifier(token t) { $t }
auto number to_number(token t) { $t }
auto string to_string(token t) { $t }


struct Nuller {
	export/interface Core;
	export/implementation Core;
	
	
};



template<class T> struct CPtr {
	export/interface Core;
	export/implementation Core;
	
	T* value;
	
	CPtr() : value(0) {}
	CPtr(T* p) : value(p) {}
	void operator=(T* p) {value = p;}
	void operator=(Nuller p) {value = 0;}
	operator T*() const {return value;}
};


namespace {

export/interface Core;
export/implementation Core;


extern Nuller Null;

auto declaration ForceGlobalVisible(token t) {
	extern typename $t $to_identifier("____unused_"$t);
}

auto declaration GlobalTypedef(token from, token to) {
	typedef $from $to;
	extern $to_identifier($to) $to_identifier("____unused_"$to);
}

auto declaration GlobalTypedefPtr(token from, token to) {
	typedef CPtr<$from> $to;
	extern $to_identifier($to) $to_identifier("____unused_"$to);
}

void Break(const char* msg);
	
$GlobalTypedef(char,				int8);
$GlobalTypedef(unsigned short,		uint16);
$GlobalTypedef(short,				int16);
$GlobalTypedef(unsigned int,		uint32);
$GlobalTypedef(int,					int32);
$GlobalTypedef(unsigned long long,	uint64);
$GlobalTypedef(long long,			int64);
$GlobalTypedef(unsigned char,		Byte);
$GlobalTypedef(unsigned char,		byte);
$GlobalTypedef(uint16,				word);
$GlobalTypedef(uint32,				dword);
$GlobalTypedef(uint64,				qword);
$GlobalTypedef(unsigned long,		DWORD);
$GlobalTypedefPtr(const char,		CString);
$GlobalTypedefPtr(void,				VOID_PTR);
$GlobalTypedefPtr(const void,		CONST_VOID_PTR);



template <class T>
inline void IGNORE_RESULT(const T&) {}



}


#define ASSERT(e) {if (!(e)) {Break("Assertion failed: " #e);}}
#define PANIC(msg) Break(msg);


