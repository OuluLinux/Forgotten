



namespace Com {
using/interface C;

typedef C::Nuller Nuller;
extern C::Nuller Null;

!inline void* MemoryAlloc(int sz) {return C::Memory::Alloc(sz);}
!inline void MemoryFree(void* ptr) {C::Memory::Free(ptr);}
!inline int MemoryCompare(const void* m1, const void* m2, int sz) {return C::Memory::Compare(m1,m2,sz);}
!inline void* MemoryCopy(void *dest, const void* src, int sz) {return C::Memory::Copy(dest,src,sz);}
!inline void* MemoryMove(void *dest, const void* src, int sz) {return C::Memory::Move(dest,src,sz);}
!inline void MemorySet(void *dest, int byte_value, int sz) {C::Memory::Set(dest,byte_value,sz);}
!inline void Break(const char* msg) {C::SysBreak(msg);}

#define ASSERT(e) {if (!(e)) {Break("Assertion failed: " #e);}}
#define PANIC(msg) Break(msg);

auto character to_character(token t) { $t }
auto identifier to_identifier(token t) { $t }
auto number to_number(token t) { $t }
auto string to_string(token t) { $t }
auto type to_type(token t) { $t }


auto declaration ForceGlobalVisible(token t) {
	extern typename $t $to_identifier("____unused_"$t);
}

auto declaration GlobalTypedef(token from, token to) {
	typedef $from $to;
	extern $to_identifier($to) $to_identifier("____unused_"$to);
}

auto declaration GlobalTypedefPtr(token from, token to) {
	typedef C::Ptr<$from> $to;
	extern $to_identifier($to) $to_identifier("____unused_"$to);
}


$GlobalTypedef(unsigned char,		uint8);
$GlobalTypedef(char,				int8);
$GlobalTypedef(unsigned short,		uint16);
$GlobalTypedef(short,				int16);
$GlobalTypedef(unsigned int,		uint32);
$GlobalTypedef(int,					int32);
$GlobalTypedef(unsigned long long,	uint64);
$GlobalTypedef(long long,			int64);
$GlobalTypedef(unsigned char,		Byte);
$GlobalTypedef(unsigned char,		byte);
$GlobalTypedef(uint16,				word);
$GlobalTypedef(uint32,				dword);
$GlobalTypedef(uint64,				qword);
$GlobalTypedef(unsigned long,		DWORD);
$GlobalTypedefPtr(const char,		CString);
$GlobalTypedefPtr(void,				VoidPtr);
$GlobalTypedefPtr(const void,		ConstVoidPtr);


auto string PLATFORM = "UNKNOWN";
auto number CPU_32 = 0;
auto number CPU_64 = 0;
auto number PTRSIZE = 0;

auto if ($IsDefined("CPU64")) {
	$DebugMetaLog("Using 64bit cpu");
	
	auto CPU_64 = 1;
	auto PTRSIZE = 8;
}
else if ($IsDefined("CPU32")) {
	$DebugMetaLog("Using 32bit cpu");
	
	auto CPU_64 = 1;
	auto PTRSIZE = 4;
}
else $std::error("Define cpu bits: CPU32 or CPU64");

auto if ($IsDefined("POSIX")) {
	$DebugMetaLog("Using Posix OS");
	
	auto string DIR_SEPS = "/";
	auto char DIR_SEP = '/';
	auto string ENDL = "\n";
	auto PLATFORM = "POSIX";
}
else if ($IsDefined("WIN32")) {
	$DebugMetaLog("Using Windows OS");
	
	auto string DIR_SEPS = "\\";
	auto char DIR_SEP = '\\';
	auto string ENDL = "\r\n";
	auto PLATFORM = "POSIX";
}
else
	$std::error("No OS defined. Define POSIX or WIN32");



typedef C::AtomicFlag SpinLock;




template <class T>
inline void IGNORE_RESULT(const T&) {}




}


